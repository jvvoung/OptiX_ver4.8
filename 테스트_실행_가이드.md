# OptiX 프로세스 종료 문제 - 테스트 실행 가이드

## 📋 목차
1. [빌드 및 준비](#빌드-및-준비)
2. [테스트 시나리오](#테스트-시나리오)
3. [점검 도구 사용법](#점검-도구-사용법)
4. [문제 재현 방법](#문제-재현-방법)
5. [수정 후 검증](#수정-후-검증)

---

## 🔧 빌드 및 준비

### 1. Process DLL 빌드 (C++)

#### Visual Studio에서 빌드
```
1. Visual Studio 2019/2022 실행
2. OptiX.sln 열기
3. 솔루션 구성: Release / x64 선택
4. Process 프로젝트 우클릭 → 빌드
5. 빌드 결과 확인: x64\Release\Process.dll
```

#### 명령줄에서 빌드 (MSBuild)
```cmd
cd D:\OptiX_48
msbuild Process\Process.vcxproj /p:Configuration=Release /p:Platform=x64
```

**예상 출력**:
```
Process.dll -> D:\OptiX_48\x64\Release\Process.dll
```

---

### 2. OptiX UI 빌드 (C#)

#### Visual Studio에서 빌드
```
1. OptiX_UI 프로젝트 우클릭 → 빌드
2. 빌드 결과 확인: OptiX_UI\bin\Release\OptiX.exe
```

#### 명령줄에서 빌드 (MSBuild)
```cmd
cd D:\OptiX_48
msbuild OptiX_UI\OptiX_UI.csproj /p:Configuration=Release /p:Platform=AnyCPU
```

---

### 3. 배포 폴더 준비

#### 배포 스크립트 (예시)
```cmd
@echo off
echo ========== OptiX 배포 준비 ==========

REM 배포 폴더 생성
set DEPLOY_DIR=D:\OptiX_48\publish_test
if not exist "%DEPLOY_DIR%" mkdir "%DEPLOY_DIR%"

REM Exe 복사
copy /Y "D:\OptiX_48\OptiX_UI\bin\Release\OptiX.exe" "%DEPLOY_DIR%\"
copy /Y "D:\OptiX_48\OptiX_UI\bin\Release\OptiX.exe.config" "%DEPLOY_DIR%\"

REM DLL 복사
copy /Y "D:\OptiX_48\x64\Release\Process.dll" "%DEPLOY_DIR%\"
copy /Y "D:\OptiX_48\x64\Release\Process.pdb" "%DEPLOY_DIR%\"

REM INI 파일 복사
copy /Y "D:\OptiX_48\OptiX.ini" "%DEPLOY_DIR%\"

echo ========== 배포 완료 ==========
echo 배포 폴더: %DEPLOY_DIR%
pause
```

---

## 🧪 테스트 시나리오

### 시나리오 1: 정상 종료 테스트

#### 목적
프로그램 정상 종료 시 모든 리소스가 해제되는지 확인

#### 절차
```
1. OptiX.exe 실행
2. OPTIC 페이지로 이동
3. START 버튼 클릭 → 테스트 진행
4. 테스트 완료 대기 (모든 Zone 완료)
5. X 버튼으로 프로그램 종료
6. 작업 관리자 확인 (Ctrl+Shift+Esc)
```

#### 예상 결과 (✅ 성공)
- [ ] 프로그램이 1초 이내에 종료됨
- [ ] 작업 관리자에 OptiX.exe 프로세스 없음
- [ ] 포트 7777이 해제됨 (netstat 확인)
- [ ] ErrorLogger.log에 "모든 장비 리소스 해제 완료" 기록

#### 예상 결과 (❌ 실패 - 수정 전)
- 프로세스가 3초 이상 남아있음
- 파일 복사 시도 시 "실행 중" 오류

---

### 시나리오 2: 테스트 실행 중 강제 종료

#### 목적
비동기 작업 실행 중 종료 시 CancellationToken이 제대로 동작하는지 확인

#### 절차
```
1. OptiX.exe 실행
2. OPTIC 페이지 → START 버튼 클릭
3. Zone별 시퀀스 진행 중 (30% 완료 시점)
4. X 버튼 클릭
5. 3초 대기
6. 작업 관리자 확인
```

#### 예상 결과 (✅ 성공)
- [ ] 프로그램이 3초 이내에 종료됨
- [ ] ErrorLogger.log에 "테스트 실행 중 취소됨" 기록
- [ ] 프로세스 즉시 종료

#### 디버그 로그 확인
```
ErrorLogger.log 예시:
[2026-02-08 14:35:12] INFO - SEQUENCE1 실행 중 취소됨
[2026-02-08 14:35:12] INFO - 모든 테스트 중단 요청
[2026-02-08 14:35:13] INFO - 테스트 정상 종료됨
```

---

### 시나리오 3: RESTART 대기 중 종료

#### 목적
Semaphore 대기 중 종료 시 Linked CancellationToken이 작동하는지 확인

#### 절차
```
1. OptiX.exe 실행
2. Settings → TCP 서버 시작 (7777 포트)
3. OptiX_Client 실행 → 서버 연결
4. HVI 모드 활성화 (INI에서 SEQUENCE 2개 설정)
5. Client에서 OPTIC_START 전송 (Zone 1, Zone 2 데이터)
6. SEQUENCE1 완료 → RESTART 대기 상태 확인
   - 로그에 "⏸️ SEQUENCE1 완료 - RESTART 명령 대기 중..." 표시
7. OptiX X 버튼 클릭
```

#### 예상 결과 (✅ 성공)
- [ ] 프로그램이 즉시 종료됨 (10분 대기 안 함)
- [ ] "프로그램 종료로 RESTART 대기 취소됨" 로그
- [ ] Semaphore가 즉시 해제됨

#### 예상 결과 (❌ 실패 - 수정 전)
- 프로그램이 10분간 멈춤 (타임아웃 대기)
- 강제 종료 필요 (작업 관리자)

---

### 시나리오 4: 파일 교체 테스트

#### 목적
프로세스 종료 후 Exe 파일 핸들이 해제되는지 확인

#### 절차
```
1. OptiX.exe 실행 → 정상 종료
2. publish_test 폴더에서 OptiX_backup.exe 준비
3. 명령 프롬프트에서 복사 시도:
   copy /Y "OptiX_backup.exe" "OptiX.exe"
4. 복사 성공 여부 확인
5. 새 OptiX.exe 실행 → OPTIC Port Connect 테스트
```

#### 예상 결과 (✅ 성공)
- [ ] 파일 복사 성공 (잠김 오류 없음)
- [ ] 새 버전 실행 시 포트 정상 연결

#### 예상 결과 (❌ 실패 - 수정 전)
```
오류 메시지:
다른 프로세스에서 파일을 사용하고 있기 때문에
프로세스가 해당 파일에 액세스할 수 없습니다.
```

---

### 시나리오 5: 통신 서버 실행 중 종료

#### 목적
백그라운드 스레드(AcceptClientsAsync, HandleClientAsync)가 제대로 종료되는지 확인

#### 절차
```
1. OptiX.exe 실행
2. Settings → Connect 버튼 클릭 (TCP 서버 시작)
3. Client 연결 확인 (AUTO MODE 표시)
4. X 버튼 클릭
5. PowerShell에서 포트 확인:
   netstat -ano | findstr :7777
```

#### 예상 결과 (✅ 성공)
- [ ] 서버가 3초 이내에 종료됨
- [ ] `netstat` 결과에서 7777 포트 없음
- [ ] Client에 SERVER_SHUTDOWN 메시지 전송됨

#### 예상 결과 (❌ 실패 - 수정 전)
```
netstat 출력:
TCP    0.0.0.0:7777    0.0.0.0:0    LISTENING    12345
```
→ 프로세스 PID 12345가 살아있음

---

## 🛠️ 점검 도구 사용법

### 1. 작업 관리자 (Task Manager)

#### 프로세스 확인
```
1. Ctrl+Shift+Esc → 작업 관리자 실행
2. "세부 정보" 탭 클릭
3. "이름" 열에서 "OptiX.exe" 검색
4. CPU/메모리 사용량 확인
```

**정상 상태**:
- 프로그램 종료 후 OptiX.exe가 목록에 없음

**비정상 상태**:
- OptiX.exe가 남아있음
- CPU 0%, 메모리 고정 → 데드락 가능성

---

### 2. netstat (네트워크 포트 확인)

#### TCP 포트 7777 확인
```powershell
# PowerShell에서 실행
netstat -ano | findstr :7777
```

**출력 예시 (서버 실행 중)**:
```
TCP    0.0.0.0:7777    0.0.0.0:0    LISTENING    12345
TCP    127.0.0.1:7777  127.0.0.1:54321  ESTABLISHED  12345
```

**출력 없음 (정상 종료)**:
```
(빈 출력)
```

#### PID로 프로세스 확인
```powershell
tasklist | findstr 12345
```

**출력**:
```
OptiX.exe    12345 Console    1    125,456 K
```

---

### 3. Handle.exe (Sysinternals)

#### 다운로드 및 설치
```
1. https://learn.microsoft.com/en-us/sysinternals/downloads/handle 방문
2. Handle.zip 다운로드
3. 압축 해제 → handle.exe를 PATH에 추가
```

#### 파일 핸들 확인
```cmd
handle.exe -p OptiX.exe
```

**출력 예시**:
```
OptiX.exe  pid: 12345  type: File
  3C0: C:\OptiX\Process.dll
  3C4: C:\OptiX\OptiX.exe
  3C8: C:\OptiX\ErrorLogger.log
```

#### 특정 파일을 점유하는 프로세스 확인
```cmd
handle.exe "D:\OptiX_48\publish_test\OptiX.exe"
```

---

### 4. Process Explorer (Sysinternals)

#### 다운로드 및 사용법
```
1. https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer
2. procexp.exe 실행 (관리자 권한)
3. OptiX.exe 프로세스 더블클릭
4. "Threads" 탭 → 스레드 개수 확인
5. "Handles" 탭 → 열린 파일/포트 확인
```

**정상 상태**:
- 스레드 1개 (Main Thread)

**비정상 상태**:
- 스레드 3개 이상 (백그라운드 스레드 남음)
- Call Stack에서 `AcceptTcpClientAsync` 보임

---

### 5. ErrorLogger.log 분석

#### 로그 파일 위치
```
D:\Project\Recipe\Log\Error\ErrorLogger_2026-02-08.log
```

#### 정상 종료 로그 예시
```
[2026-02-08 14:30:00] INFO - 프로그램 종료 시작
[2026-02-08 14:30:00] INFO - 모든 테스트 중단 요청
[2026-02-08 14:30:01] INFO - 테스트 정상 종료됨
[2026-02-08 14:30:01] INFO - 장비 리소스 해제: 성공
[2026-02-08 14:30:02] INFO - DLL 리소스 해제 완료
[2026-02-08 14:30:02] INFO - ErrorLogger 종료 완료
```

#### 비정상 종료 로그 예시 (수정 전)
```
[2026-02-08 14:30:00] INFO - 프로그램 종료 시작
[2026-02-08 14:30:03] WARNING - 서버 중지 타임아웃 (3초 초과) - 강제 종료
[2026-02-08 14:30:03] WARNING - 테스트 종료 타임아웃 (강제 종료)
```

---

## 🔍 문제 재현 방법

### 재현 시나리오 A: 통신 서버 백그라운드 스레드 남음

#### 재현 조건
- CancellationToken 없이 Accept/Handle 루프 실행
- StopServerAsync에서 Wait 타임아웃 발생

#### 재현 절차
```
1. 코드 수정 (테스트용 - 수정 전 코드로 되돌림):
   - CommunicationServer.cs:129 → cancellationTokenSource?.Cancel(); 주석 처리
2. 빌드 후 실행
3. TCP 서버 시작 → Client 연결
4. X 버튼 클릭
5. 작업 관리자 확인
```

**예상 결과**:
- 프로세스가 3초 이상 남음
- AcceptTcpClientAsync가 대기 중

---

### 재현 시나리오 B: RESTART Semaphore 대기 데드락

#### 재현 조건
- Linked CancellationToken 없이 Semaphore.WaitAsync 호출
- 프로그램 종료 시 취소 신호 없음

#### 재현 절차
```
1. 코드 수정 (테스트용):
   - OpticSeqExecutor.cs:246 라인을
     "await restartSemaphore.WaitAsync(cts.Token);"로 변경 (Linked Token 제거)
2. HVI 모드 + AUTO MODE 실행
3. SEQUENCE1 완료 → RESTART 대기
4. X 버튼 클릭
```

**예상 결과**:
- 프로그램이 10분간 멈춤
- CPU 0%, 응답 없음

---

### 재현 시나리오 C: Timer 미정리로 콜백 실행

#### 재현 조건
- Timer.Dispose() 호출 없음
- 타이머 콜백이 UI 스레드 접근 시도

#### 재현 절차
```
1. 코드 수정 (테스트용):
   - MainWindow.xaml.cs:563 → opticTestTimer?.Dispose(); 주석 처리
2. Client에서 Zone 데이터 전송 (타이머 시작)
3. 즉시 X 버튼 클릭 (200ms 내)
```

**예상 결과**:
- 프로그램 종료 후 타이머 콜백 실행 시도
- NullReferenceException 가능

---

## ✅ 수정 후 검증

### 검증 체크리스트

#### 1. 빌드 확인
- [ ] Process.dll 빌드 성공 (경고 없음)
- [ ] OptiX.exe 빌드 성공 (경고 없음)
- [ ] 배포 폴더에 모든 파일 복사됨

#### 2. 정상 종료 검증
- [ ] 시나리오 1 성공 (1초 이내 종료)
- [ ] 작업 관리자에 프로세스 없음
- [ ] netstat에 포트 7777 없음
- [ ] ErrorLogger.log에 "모든 장비 리소스 해제 완료" 기록

#### 3. 강제 종료 검증
- [ ] 시나리오 2 성공 (3초 이내 종료)
- [ ] 로그에 "테스트 실행 중 취소됨" 기록

#### 4. RESTART 대기 검증
- [ ] 시나리오 3 성공 (즉시 종료, 10분 대기 안 함)
- [ ] 로그에 "프로그램 종료로 RESTART 대기 취소됨" 기록

#### 5. 파일 교체 검증
- [ ] 시나리오 4 성공 (복사 오류 없음)
- [ ] 새 버전 실행 시 포트 정상 연결

#### 6. 통신 서버 검증
- [ ] 시나리오 5 성공 (서버 정상 종료)
- [ ] Client에 SERVER_SHUTDOWN 전송됨

---

### 성능 측정

#### 종료 시간 측정 스크립트
```powershell
# PowerShell 스크립트 (measure_shutdown.ps1)
$sw = [Diagnostics.Stopwatch]::StartNew()
Start-Process "D:\OptiX_48\publish_test\OptiX.exe" -Wait
$sw.Stop()
Write-Host "실행 시간: $($sw.Elapsed.TotalSeconds) 초"

# 프로세스 종료 (X 버튼 클릭 시뮬레이션은 수동)
# 종료 후 다시 측정
$sw.Restart()
Wait-Process -Name "OptiX" -ErrorAction SilentlyContinue
$sw.Stop()
Write-Host "종료 시간: $($sw.Elapsed.TotalSeconds) 초"
```

**목표 성능**:
- 정상 종료: **< 1초**
- 강제 종료 (테스트 실행 중): **< 3초**
- RESTART 대기 중 종료: **< 1초**

---

### 디버그 빌드 vs 릴리즈 빌드

#### 디버그 빌드 테스트
```
1. Configuration: Debug / x64
2. 빌드 후 실행
3. Visual Studio → 디버그 → 프로세스에 연결
4. 종료 시점에 "디버그 → 모두 중단"
5. Call Stack 확인
```

**확인 사항**:
- CommunicationServer.AcceptClientsAsync 스레드가 종료되었는지
- OpticSeqExecutor.StartTestAsync의 CancellationToken이 취소되었는지

#### 릴리즈 빌드 테스트
```
1. Configuration: Release / x64
2. 빌드 후 배포
3. 실제 환경에서 테스트 (5회 반복)
```

---

## 🐛 문제 해결 FAQ

### Q1: "Process.dll을 찾을 수 없습니다" 오류
**원인**: DLL 경로 설정 오류

**해결**:
```
1. OptiX.ini 열기
2. [Settings] DLL_FOLDER 확인
3. 경로를 배포 폴더로 수정
4. 재실행
```

---

### Q2: 프로세스가 여전히 남아있음
**원인**: 백그라운드 스레드 종료 실패

**해결**:
```
1. Process Explorer로 스레드 확인
2. ErrorLogger.log 확인
3. StopServerAsync 타임아웃 로그 확인
4. Visual Studio 디버거로 Call Stack 분석
```

---

### Q3: 포트 7777이 해제되지 않음
**원인**: TcpListener.Stop() 호출 누락

**해결**:
```powershell
# 강제로 포트 해제 (임시)
netstat -ano | findstr :7777
# PID 확인 후
taskkill /PID <PID> /F
```

---

### Q4: 파일 복사 시 "액세스 거부" 오류
**원인**: 파일 핸들이 아직 열려있음

**해결**:
```
1. handle.exe "D:\OptiX_48\publish_test\OptiX.exe"
2. 점유 프로세스 PID 확인
3. 해당 프로세스 강제 종료
4. 재시도
```

---

## 📊 결과 보고서 템플릿

### 테스트 결과 보고서

**테스트 일시**: 2026-02-08 14:00  
**테스터**: [이름]  
**빌드 버전**: Release 1.0.0  

#### 시나리오 결과

| 시나리오 | 결과 | 종료 시간 | 비고 |
|---------|------|----------|------|
| 정상 종료 | ✅ PASS | 0.8초 | |
| 강제 종료 | ✅ PASS | 2.1초 | |
| RESTART 대기 중 종료 | ✅ PASS | 0.9초 | |
| 파일 교체 | ✅ PASS | - | |
| 통신 서버 종료 | ✅ PASS | 2.5초 | |

#### 추가 검증

- [x] 작업 관리자에 프로세스 없음
- [x] netstat에서 포트 해제 확인
- [x] ErrorLogger.log에 정상 종료 로그
- [x] 파일 핸들 해제됨

#### 문제점 및 개선사항
- 없음

---

**작성일**: 2026-02-08  
**버전**: 1.0  
**작성자**: AI Assistant (Claude Sonnet 4.5)
